PRAGMATIC SIMPLIFICATION ANALYSIS - Making Code Make Sense v2.0

STEP 1: Hot Path Performance Baseline & Budget Verification
**Goal**: Establish current performance reality before any optimization
**Actions**:
- Measure software-only MIDI→Audio latency for 100+ events (starting from MidiService, not hardware)
- Track memory allocations per MIDI event using Chrome's performance.memory API
- Monitor GC frequency and pause duration during 5-minute practice sessions
- Profile each stage against documented budget (1ms Main, 2ms IPC, 3ms React, 11ms Audio)
- Use existing performance logger from CLAUDE.md (ring buffer for hot paths)
**Deliverable**: Performance baseline report with p50/p95/p99 latencies
**Success Criteria**: All software stages <18ms total, any >20ms outliers documented

STEP 2: State Management Audit - Zustand Violations & Efficiency
**Goal**: Ensure state lives where it should and updates efficiently
**Actions**:
- grep -r "useState\|useReducer" src/renderer/ | grep -v "local UI state"
- Profile components re-rendering on MIDI events using React DevTools Profiler
- Review all Zustand store actions for reducer-like complexity that could be simpler
- Test granular selectors (state => state.lastResult) vs whole-store subscriptions
- Check for component-level MIDI subscriptions violating "Single Source of Truth"
**Deliverable**: State violations table with migration plans and complexity scores
**Success Criteria**: Zero shared state outside Zustand, <3ms React reconciliation

STEP 3: OSMD Library Alignment - Stop Reinventing the Wheel
**Goal**: Use native OSMD features instead of custom implementations
**Actions**:
- Compare src/renderer/hooks/useOSMD.ts cursor control vs OSMD's cursor.next(), show()
- Audit note coloring implementation vs OSMD's sourceNote.noteheadColor API
- Check for custom event handling that duplicates OSMD's built-in methods
- Review ADR-007 for justified OSMD customizations (MeasureList orientation)
- Measure performance impact of switching to native APIs
**Deliverable**: "Reinvented Wheel" report with before/after code examples
**Success Criteria**: 50%+ reduction in custom OSMD wrapper code, no performance regression

STEP 4: Real-Time Audio/MIDI Optimizations
**Goal**: Optimize the critical path for <20ms latency with modern best practices
**Actions**:
- Verify AudioWorklet usage (not deprecated ScriptProcessorNode)
- Ensure audio processing completes within 3ms budget (128 samples/48kHz)
- Audit buffer allocation strategy - profile actual polyphony vs pre-allocated buffers
- Check for ring buffer implementation for efficient memory management
- Consider WebAssembly for computation-heavy processing to avoid GC
- Implement lookahead scheduling following Web Audio best practices
- Test SharedArrayBuffer for lock-free main/audio thread communication
**Deliverable**: Optimized audio pipeline with detailed latency measurements
**Success Criteria**: Consistent <18ms latency, 3ms audio processing, zero GC pauses

STEP 5: Developer Experience & Debugging Tools
**Goal**: Make complex real-time debugging easier and faster
**Actions**:
- Integrate Zustand DevTools or lightweight state diff logger (dev mode only)
- Enhance performance overlay (Ctrl+Shift+P) with live metrics:
  - MIDI event rate and latency
  - IPC message size and frequency
  - Audio scheduling delays
  - Memory allocation rate
- Create debugging cookbook for common latency issues
- Add automated latency regression alerts to development workflow
- Document "quick start" guides for common tasks (adding practice modes)
**Deliverable**: Enhanced dev tools, debugging guide, and onboarding docs
**Success Criteria**: 50% reduction in latency debugging time, new dev productive in <1 hour

STEP 6: Build & Configuration Pragmatism
**Goal**: Simplify tooling without sacrificing necessary features
**Actions**:
- Create table of all non-default settings in vite.config.ts, tsconfig.json, .eslintrc
- Cross-reference each deviation with CLAUDE.md or ADR justification
- Measure cold build time: tsc --build && npm run lint && npm test
- Measure incremental build time after typical file edit
- Remove ESLint stylistic rules already enforced by Prettier
- Audit package.json for overlapping tools (multiple bundlers, formatters)
**Deliverable**: Config justification table and build performance benchmarks
**Success Criteria**: <2s incremental builds, 50% fewer config overrides, clear rationale

STEP 7: Type System & Error Handling Simplification
**Goal**: Reduce cognitive overhead while maintaining safety
**Actions**:
- Find complex generics: grep -r "<.*<.*>>" --include="*.ts" --include="*.tsx"
- Audit conditional types and utility type gymnastics (Pick<Omit<...>>)
- Review all try-catch blocks and categorize:
  - Recover: Implements specific recovery logic (keep)
  - Report & Rethrow: Could use global handler instead
  - Swallow: Empty or console.log only (flag as anti-pattern)
- Find non-null assertions (!) on TypeScript-guaranteed non-null properties
- Review Zustand error state that could use React Error Boundaries
**Deliverable**: Type/error simplification report with refactoring examples
**Success Criteria**: 30% reduction in type complexity, unified error handling strategy

STEP 8: Architecture & Abstraction Audit (YAGNI)
**Goal**: Remove layers that don't add value
**Actions**:
- Find all interfaces/abstract classes with single implementations
- Identify pass-through functions: grep -B2 -A2 "return.*\(" | grep -v "processing"
- Review src/shared/ - verify each export is truly used by both processes
- Audit service layers in src/main/services/ and src/renderer/services/
- Check for over-engineered factories/builders for simple object creation
- Map dependency flow to identify unnecessary indirection
**Deliverable**: YAGNI list with direct replacement code and LOC reduction estimate
**Success Criteria**: 20%+ reduction in abstraction layers, cleaner import graph

STEP 9: Memory & Resource Management
**Goal**: Prevent performance degradation over time
**Actions**:
- Monitor heap growth: performance.memory.usedJSHeapSize over 60-minute session
- Automated stress test: Load/dispose OSMD 100x, check for detached DOM trees
- Audit all useEffect cleanups - verify event listeners removed
- Check AudioContext disposal and Web Audio node cleanup
- Test MIDI hot-plug 50x - connect/disconnect virtual devices rapidly
- Profile for retained closures holding large objects
- Review Web Worker termination and cleanup
**Deliverable**: Resource leak report with heap snapshots and fixes
**Success Criteria**: <200MB after 1 hour, zero leaks in stress tests

STEP 10: Automated Simplification Metrics (CI Integration)
**Goal**: Prevent complexity from creeping back
**Actions**:
- Create simplification-metrics.ts script that runs in CI:
  - tokei or cloc for lines of code trends
  - madge --circular for import cycles
  - gzipper for bundle size tracking
  - Custom script for latency budget verification
  - IPC payload size monitoring (log 95th percentile)
- Set up GitHub Actions to run on every PR
- Configure alerts for threshold breaches:
  - Latency >20ms
  - Bundle growth >5%
  - New circular dependencies
  - Memory usage >200MB
**Deliverable**: CI configuration with automated reporting
**Success Criteria**: All metrics tracked, regressions caught before merge

FINAL STEP: Implementation Roadmap
**Goal**: Prioritize changes by impact and effort
**Actions**:
- Group findings by dependency order (e.g., YAGNI before optimization)
- Calculate complexity reduction score: (LOC removed + abstractions removed) / effort
- Identify quick wins (<1 day) vs major refactors (>1 week)
- Consider feature velocity impact - defer low-impact changes
- Create phased plan respecting ADR-004 (developer-friendly → production-hardened)
- Define measurable checkpoints between phases
**Deliverable**: SIMPLIFICATION-ROADMAP.md with timeline and dependencies
**Success Criteria**: Clear 3-phase plan from current state to simplified architecture

KEY PRINCIPLES:
- Measure First: No optimization without data
- User Impact: Focus on <20ms latency and developer velocity
- Pragmatic Approach: Some complexity is justified if it serves the mission
- Incremental Progress: Small improvements compound
- Automated Enforcement: Manual audits regress; automated checks persist
- Dependencies Matter: Implementation order affects success