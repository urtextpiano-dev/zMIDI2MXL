# Function Analysis: detectChords

## Metadata
- **File**: `src/harmony/minimal_chord_detector.zig`
- **Lines**: 10-98 (89 lines)
- **Type**: function
- **Visibility**: public
- **Signature**: `pub fn detectChords(self: *MinimalChordDetector, notes: []const TimedNote) ![]ChordGroup {`

## Function Content
```zig
    pub fn detectChords(self: *MinimalChordDetector, notes: []const TimedNote) ![]ChordGroup {
        if (notes.len == 0) return self.allocator.alloc(ChordGroup, 0);
        
        // Check if already sorted (common case from pipeline)
        var is_sorted = true;
        for (1..notes.len) |i| {
            if (notes[i].start_tick < notes[i-1].start_tick) {
                is_sorted = false;
                break;
            }
        }
        
        // Only copy and sort if necessary
        const sorted = if (is_sorted) notes else blk: {
            const copy = try self.allocator.alloc(TimedNote, notes.len);
            @memcpy(copy, notes);
            std.sort.pdq(TimedNote, copy, {}, compareByStartTick);
            break :blk copy;
        };
        defer if (!is_sorted) self.allocator.free(sorted);
        
        // Pre-allocate groups array with estimated size
        var groups = try std.ArrayList(ChordGroup).initCapacity(self.allocator, notes.len / 2);
        defer groups.deinit();
        
        var i: usize = 0;
        while (i < sorted.len) {
            const base_tick = sorted[i].start_tick;
            const start_idx = i;
            
            // Count notes at same tick (no allocation)
            var count: usize = 0;
            while (i < sorted.len and sorted[i].start_tick == base_tick) : (i += 1) {
                count += 1;
            }
            
            const chord_slice = sorted[start_idx..start_idx + count];
            
            // Fast path for single notes (most common)
            if (count == 1) {
                const single = try self.allocator.alloc(TimedNote, 1);
                single[0] = chord_slice[0];
                
                const tracks = try self.allocator.alloc(u8, 1);
                tracks[0] = chord_slice[0].track;
                
                try groups.append(ChordGroup{
                    .start_time = base_tick,
                    .notes = single,
                    .staff_assignment = if (chord_slice[0].note < 60) 2 else 1,
                    .tracks_involved = tracks,
                    .is_cross_track = false,
                });
            } else if (validateChordGroupFast(chord_slice)) {
                // Valid chord: copy and sort by pitch
                const owned = try self.allocator.alloc(TimedNote, count);
                @memcpy(owned, chord_slice);
                std.sort.pdq(TimedNote, owned, {}, compareByPitch);
                
                const tracks = try collectTracksFast(self.allocator, owned);
                try groups.append(ChordGroup{
                    .start_time = base_tick,
                    .notes = owned,
                    .staff_assignment = determineStaff(owned),
                    .tracks_involved = tracks,
                    .is_cross_track = tracks.len > 1,
                });
            } else {
                // Fail-safe: create individual note groups
                for (chord_slice) |note| {
                    const single = try self.allocator.alloc(TimedNote, 1);
                    single[0] = note;
                    
                    const tracks = try self.allocator.alloc(u8, 1);
                    tracks[0] = note.track;
                    
                    try groups.append(ChordGroup{
                        .start_time = note.start_tick,
                        .notes = single,
                        .staff_assignment = if (note.note < 60) 2 else 1,
                        .tracks_involved = tracks,
                        .is_cross_track = false,
                    });
                }
            }
        }
        
        return groups.toOwnedSlice();
    }
```

## Analysis Template (To be completed by simplification agent)

### Current Implementation Analysis
- **Purpose**: [Function's role in MIDI-to-MXL conversion]
- **Algorithm**: [How the function works]
- **Complexity**: [Time/space complexity, cyclomatic complexity]
- **Pipeline Role**: [Where this fits in the conversion pipeline]

### Simplification Opportunity
- **Proposed Change**: [Specific simplification identified]
- **Rationale**: [Why this simplification improves the code]
- **Complexity Reduction**: [Measurable improvement metrics]

### Evidence Package
- **Functional Proof**: [Demonstration of equivalence]
- **Performance Data**: [Before/after benchmarks if applicable]
- **Test Results**: [Validation of correctness]
- **Risk Assessment**: [Potential issues and mitigations]

### Recommendation
- **Confidence Level**: [0-100% with justification]
- **Implementation Priority**: [High/Medium/Low with reasoning]
- **Prerequisites**: [Dependencies or requirements]
