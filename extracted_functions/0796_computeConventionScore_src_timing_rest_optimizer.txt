# Function Analysis: computeConventionScore

## Metadata
- **File**: `src/timing/rest_optimizer.zig`
- **Lines**: 658-690 (33 lines)
- **Type**: function
- **Visibility**: private
- **Signature**: `fn computeConventionScore(self: *RestOptimizer, rest_type: NoteType, position_in_measure: u32, time_sig: TimeSignature) f32 {`

## Function Content
```zig
    fn computeConventionScore(self: *RestOptimizer, rest_type: NoteType, position_in_measure: u32, time_sig: TimeSignature) f32 {
        var score: f32 = 0.0;
        
        // 4/4 time specific patterns
        if (time_sig.numerator == 4 and time_sig.denominator == 4) {
            // Whole rest at start of measure
            if (position_in_measure == 0 and rest_type == .whole) {
                score += self.config.convention_weight * 1.0;
            }
            // Half rest at start or middle of measure
            else if ((position_in_measure == 0 or position_in_measure == time_sig.beat_duration * 2) and rest_type == .half) {
                score += self.config.convention_weight * 0.8;
            }
        }
        
        // 3/4 time specific patterns
        if (time_sig.numerator == 3 and time_sig.denominator == 4) {
            // Dotted half for full measure
            if (position_in_measure == 0 and rest_type == .half) {
                score += self.config.convention_weight * 0.9;
            }
        }
        
        // 6/8 time specific patterns
        if (time_sig.numerator == 6 and time_sig.denominator == 8) {
            // Dotted quarter aligns with compound beats
            if ((position_in_measure % (time_sig.beat_duration * 3 / 2) == 0) and rest_type == .quarter) {
                score += self.config.convention_weight * 0.8;
            }
        }
        
        return score;
    }
```

## Analysis Template (To be completed by simplification agent)

### Current Implementation Analysis
- **Purpose**: [Function's role in MIDI-to-MXL conversion]
- **Algorithm**: [How the function works]
- **Complexity**: [Time/space complexity, cyclomatic complexity]
- **Pipeline Role**: [Where this fits in the conversion pipeline]

### Simplification Opportunity
- **Proposed Change**: [Specific simplification identified]
- **Rationale**: [Why this simplification improves the code]
- **Complexity Reduction**: [Measurable improvement metrics]

### Evidence Package
- **Functional Proof**: [Demonstration of equivalence]
- **Performance Data**: [Before/after benchmarks if applicable]
- **Test Results**: [Validation of correctness]
- **Risk Assessment**: [Potential issues and mitigations]

### Recommendation
- **Confidence Level**: [0-100% with justification]
- **Implementation Priority**: [High/Medium/Low with reasoning]
- **Prerequisites**: [Dependencies or requirements]
