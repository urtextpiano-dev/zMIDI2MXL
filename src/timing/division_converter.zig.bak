const std = @import("std");
const log = @import("../utils/log.zig");
const verbose_logger = @import("../verbose_logger.zig");

// Implements TASK-023 per IMPLEMENTATION_TASK_LIST.md Section lines 288-297
// Division-Based Timing Converter
//
// Converts MIDI ticks to MusicXML divisions maintaining timing precision
// and handling different PPQ values from MIDI files.
// Performance target: < 1μs per conversion
//
// References MXL_Architecture_Reference.md Section 2.4 lines 153-169
// Instrumented with precision tracking per TASK-VL-002 VERBOSE_LOGGING_TASK_LIST.md lines 94-129

/// Error types for timing conversion operations
pub const TimingError = error{
    InvalidDivision,
    InvalidTickValue,
    PrecisionLoss,
    UnsupportedSMPTE,
};

/// Common MusicXML division values for optimal compatibility
/// From MXL_Architecture_Reference.md Section 2.4 lines 165-168
pub const COMMON_DIVISIONS = [_]u32{
    96,   // Allows for triplets and common subdivisions
    192,  // Higher precision
    480,  // Professional standard (matches common MIDI)
    960,  // Extended precision for complex timing
};

/// Default MusicXML divisions value when no specific requirement exists
pub const DEFAULT_DIVISIONS: u32 = 480;

/// Maximum precision loss acceptable during conversion (in percentage)
const MAX_PRECISION_LOSS: f64 = 0.01; // 1%

/// Division-Based Timing Converter
/// Implements TASK-023 per IMPLEMENTATION_TASK_LIST.md lines 288-297
pub const DivisionConverter = struct {
    midi_ppq: u32,           // MIDI pulses per quarter note
    musicxml_divisions: u32, // MusicXML divisions per quarter note
    conversion_ratio: f64,   // Pre-calculated ratio for performance
    
    /// Initialize converter with MIDI PPQ and target MusicXML divisions
    /// Uses optimal divisions value if target_divisions is 0
    pub fn init(midi_ppq: u32, target_divisions: u32) TimingError!DivisionConverter {
        if (midi_ppq == 0) {
            return TimingError.InvalidDivision;
        }
        
        const divisions = if (target_divisions == 0) 
            selectOptimalDivisions(midi_ppq) 
        else 
            target_divisions;
            
        if (divisions == 0) {
            return TimingError.InvalidDivision;
        }
        
        const ratio = @as(f64, @floatFromInt(divisions)) / @as(f64, @floatFromInt(midi_ppq));
        
        // Track precision of ratio calculation - TASK-VL-002
        if (verbose_logger.getVerboseLogger().precision_monitor.enabled) {
            // Check if ratio results in exact conversions for common values
            const test_value: f64 = 96.0; // Common quarter note division
            const converted = test_value * ratio;
            const back = converted / ratio;
            
            verbose_logger.getVerboseLogger().precision_monitor.trackOperation(
                "DivisionConverter.init_ratio",
                test_value,
                back,
                1.0, // Expected precision: exact conversion
                .{
                    .file = "timing/division_converter.zig",
                    .function = "init",
                    .line = 58,
                },
            );
        }
        
        return DivisionConverter{
            .midi_ppq = midi_ppq,
            .musicxml_divisions = divisions,
            .conversion_ratio = ratio,
        };
    }
    
    /// Convert MIDI ticks to MusicXML divisions
    /// Performance target: < 1μs per conversion per TASK-023
    pub fn convertTicksToDivisions(self: *const DivisionConverter, midi_ticks: u32) TimingError!u32 {
        if (midi_ticks > std.math.maxInt(u32) / 2) {
            return TimingError.InvalidTickValue;
        }
        
        // Use pre-calculated ratio for O(1) conversion
        const result_f64 = @as(f64, @floatFromInt(midi_ticks)) * self.conversion_ratio;
        
        // Add precision tracking - TASK-VL-002
        if (verbose_logger.getVerboseLogger().precision_monitor.enabled) {
            const rounded = @round(result_f64);
            
            // Track the precision loss in the conversion itself
            // We want to see if result_f64 != rounded (i.e., fractional part was lost)
            if (result_f64 != rounded) {
                verbose_logger.getVerboseLogger().precision_monitor.trackExactOperation(
                    "convertTicksToDivisions",
                    result_f64,  // The exact calculated value
                    rounded,     // The rounded value we'll use
                    .{
                        .file = "timing/division_converter.zig",
                        .function = "convertTicksToDivisions",
                        .line = 97,
                    },
                );
            }
            
            // Log detailed info for any significant precision loss
            if (@abs(result_f64 - rounded) > 0.001) {
                const vlogger = verbose_logger.getVerboseLogger();
                vlogger.data("Precision loss detected: ticks={}, ratio={d:.6}, exact={d:.6}, rounded={d}", 
                    .{midi_ticks, self.conversion_ratio, result_f64, rounded});
                vlogger.data("MIDI PPQ: {}, MusicXML divisions: {}", 
                    .{self.midi_ppq, self.musicxml_divisions});
            }
        }
        
        // Check for precision loss (avoid division by zero)
        const rounded_result = @round(result_f64);
        if (result_f64 > 1.0) { // Only check precision for meaningful values
            const precision_loss = @abs(result_f64 - rounded_result) / result_f64;
            
            if (precision_loss > MAX_PRECISION_LOSS) {
                return TimingError.PrecisionLoss;
            }
        }
        
        const result = @as(u32, @intFromFloat(rounded_result));
        return result;
    }
    
    /// Convert MusicXML divisions back to MIDI ticks
    /// Useful for validation and round-trip testing
    pub fn convertDivisionsToTicks(self: *const DivisionConverter, divisions: u32) TimingError!u32 {
        if (divisions > std.math.maxInt(u32) / 2) {
            return TimingError.InvalidTickValue;
        }
        
        const result_f64 = @as(f64, @floatFromInt(divisions)) / self.conversion_ratio;
        const result = @as(u32, @intFromFloat(@round(result_f64)));
        
        // Add precision tracking for reverse conversion - TASK-VL-002
        if (verbose_logger.getVerboseLogger().precision_monitor.enabled) {
            verbose_logger.getVerboseLogger().precision_monitor.trackOperation(
                "convertDivisionsToTicks",
                @as(f64, @floatFromInt(divisions)),
                @as(f64, @floatFromInt(result)),
                0.0, // No loss expected for exact operations
                .{
                    .file = "timing/division_converter.zig",
                    .function = "convertDivisionsToTicks",
                    .line = 98,
                },
            );
        }
        
        return result;
    }
    
    /// Get the conversion ratio (for debugging and validation)
    pub fn getConversionRatio(self: *const DivisionConverter) f64 {
        return self.conversion_ratio;
    }
    
    /// Get MIDI PPQ value
    pub fn getMidiPPQ(self: *const DivisionConverter) u32 {
        return self.midi_ppq;
    }
    
    /// Get MusicXML divisions value
    pub fn getMusicXMLDivisions(self: *const DivisionConverter) u32 {
        return self.musicxml_divisions;
    }
};

/// Select optimal MusicXML divisions value based on MIDI PPQ
/// For educational accuracy, uses divisions=4 as the base unit for clean quarter note representation
/// This ensures quarter note = 4, half note = 8, whole note = 16, eighth note = 2
fn selectOptimalDivisions(midi_ppq: u32) u32 {
    // Educational standard: Use divisions=4 for clean integer note values
    // This provides the clearest representation for student learning:
    // - Quarter note = 4 divisions (clean integer)
    // - Half note = 8 divisions (clean integer) 
    // - Whole note = 16 divisions (clean integer)
    // - Eighth note = 2 divisions (clean integer)
    const EDUCATIONAL_BASE_DIVISIONS: u32 = 4;
    
    // Find the appropriate scaling factor to maintain precision
    // We want divisions to be a multiple of 4 that gives clean conversions
    var optimal_divisions: u32 = EDUCATIONAL_BASE_DIVISIONS;
    
    // For standard PPQ values, use educational-friendly divisions
    switch (midi_ppq) {
        96 => optimal_divisions = 4,    // 96 ticks/quarter -> 4 divisions/quarter (24:1 ratio)
        192 => optimal_divisions = 8,   // 192 ticks/quarter -> 8 divisions/quarter (24:1 ratio) 
        384 => optimal_divisions = 16,  // 384 ticks/quarter -> 16 divisions/quarter (24:1 ratio)
        480 => optimal_divisions = 20,  // 480 ticks/quarter -> 20 divisions/quarter (24:1 ratio)
        960 => optimal_divisions = 40,  // 960 ticks/quarter -> 40 divisions/quarter (24:1 ratio)
        else => {
            // For non-standard PPQ values, find a divisions value that:
            // 1. Is a multiple of 4 (educational clarity)
            // 2. Provides exact or near-exact conversions for common note values
            // 3. Keeps the conversion ratio as a simple fraction when possible
            
            // Calculate GCD to find the simplest ratio
            const gcd = std.math.gcd(midi_ppq, 24); // 24 is LCM of common note divisions (1,2,3,4,6,8,12)
            _ = gcd; // May be used in future optimizations
            
            // Use the smallest multiple of 4 that gives good precision
            var test_divisions = EDUCATIONAL_BASE_DIVISIONS;
            while (test_divisions <= 96) {  // Reasonable upper bound
                const ratio = @as(f64, @floatFromInt(test_divisions)) / @as(f64, @floatFromInt(midi_ppq));
                
                // Test if this gives exact conversions for standard note lengths
                var exact_conversions: u32 = 0;
                const note_lengths = [_]u32{ midi_ppq, midi_ppq/2, midi_ppq/4, midi_ppq/8 }; // whole, half, quarter, eighth
                
                for (note_lengths) |length| {
                    if (length > 0) {
                        const converted = @as(f64, @floatFromInt(length)) * ratio;
                        if (@abs(converted - @round(converted)) < 0.001) {
                            exact_conversions += 1;
                        }
                    }
                }
                
                // If we get exact conversions for most standard notes, use this
                if (exact_conversions >= 3) {
                    optimal_divisions = test_divisions;
                    break;
                }
                
                test_divisions += 4; // Always maintain multiple of 4
            }
        }
    }
    
    // Verify the result is in our acceptable range
    if (optimal_divisions == 0 or optimal_divisions > 96) {
        optimal_divisions = EDUCATIONAL_BASE_DIVISIONS;
    }
    
    return optimal_divisions;
}

/// Create converter from MIDI Division union type
/// Implements support for different PPQ values per TASK-023
pub fn createFromMidiDivision(division: @import("../midi/parser.zig").Division, target_divisions: u32) TimingError!DivisionConverter {
    switch (division) {
        .ticks_per_quarter => |ppq| {
            return DivisionConverter.init(ppq, target_divisions);
        },
        .smpte => {
            // SMPTE timing not supported for MusicXML conversion
            return TimingError.UnsupportedSMPTE;
        },
    }
}

// Performance testing helpers for TASK-023 validation

/// Benchmark timing conversion performance
/// Used to verify < 1μs per conversion requirement
pub fn benchmarkConversion(converter: *const DivisionConverter, iterations: u32) u64 {
    const start_time = std.time.nanoTimestamp();
    
    var i: u32 = 0;
    while (i < iterations) : (i += 1) {
        const test_tick = (i % 1000) + 1; // Vary test values
        _ = converter.convertTicksToDivisions(test_tick) catch continue;
    }
    
    const end_time = std.time.nanoTimestamp();
    return @as(u64, @intCast(end_time - start_time));
}

// Tests for TASK-023 validation

test "DivisionConverter - basic initialization" {
    const converter = try DivisionConverter.init(480, 480);
    try std.testing.expectEqual(@as(u32, 480), converter.getMidiPPQ());
    try std.testing.expectEqual(@as(u32, 480), converter.getMusicXMLDivisions());
    try std.testing.expectApproxEqAbs(@as(f64, 1.0), converter.getConversionRatio(), 0.001);
}

test "DivisionConverter - different PPQ values" {
    // Test 96 PPQ to 480 divisions (5x scaling)
    const converter1 = try DivisionConverter.init(96, 480);
    try std.testing.expectEqual(@as(u32, 96), converter1.getMidiPPQ());
    try std.testing.expectEqual(@as(u32, 480), converter1.getMusicXMLDivisions());
    try std.testing.expectApproxEqAbs(@as(f64, 5.0), converter1.getConversionRatio(), 0.001);
    
    // Test 384 PPQ to 192 divisions (0.5x scaling)
    const converter2 = try DivisionConverter.init(384, 192);
    try std.testing.expectEqual(@as(u32, 384), converter2.getMidiPPQ());
    try std.testing.expectEqual(@as(u32, 192), converter2.getMusicXMLDivisions());
    try std.testing.expectApproxEqAbs(@as(f64, 0.5), converter2.getConversionRatio(), 0.001);
}

test "DivisionConverter - tick to divisions conversion" {
    const converter = try DivisionConverter.init(96, 4);  // Use educational divisions=4
    
    // Test basic conversions with educational divisions (PPQ=96, divisions=4)
    // Conversion ratio: 4/96 = 1/24 
    try std.testing.expectEqual(@as(u32, 0), try converter.convertTicksToDivisions(1));  // 1*(4/96) = 0.042 -> 0
    try std.testing.expectEqual(@as(u32, 2), try converter.convertTicksToDivisions(48)); // Half note: 48*(4/96) = 2
    try std.testing.expectEqual(@as(u32, 4), try converter.convertTicksToDivisions(96)); // Quarter note: 96*(4/96) = 4
    try std.testing.expectEqual(@as(u32, 16), try converter.convertTicksToDivisions(384)); // Whole note: 384*(4/96) = 16
}

test "DivisionConverter - round-trip conversion" {
    const converter = try DivisionConverter.init(192, 480);
    
    const test_ticks = [_]u32{ 48, 96, 192, 384, 576 }; // Remove tick=1 which causes precision issues
    
    for (test_ticks) |original_ticks| {
        const divisions = try converter.convertTicksToDivisions(original_ticks);
        const back_to_ticks = try converter.convertDivisionsToTicks(divisions);
        
        // Allow small rounding differences
        const diff = if (back_to_ticks > original_ticks) 
            back_to_ticks - original_ticks 
        else 
            original_ticks - back_to_ticks;
            
        try std.testing.expect(diff <= 1); // Maximum 1 tick difference
    }
}

test "DivisionConverter - precision maintenance" {
    const converter = try DivisionConverter.init(480, 480);
    
    // Test that exact values remain exact
    try std.testing.expectEqual(@as(u32, 120), try converter.convertTicksToDivisions(120));
    try std.testing.expectEqual(@as(u32, 240), try converter.convertTicksToDivisions(240));
    try std.testing.expectEqual(@as(u32, 480), try converter.convertTicksToDivisions(480));
}

test "DivisionConverter - optimal divisions selection" {
    // Test automatic optimal division selection
    const converter1 = try DivisionConverter.init(480, 0); // Should keep 480
    try std.testing.expectEqual(@as(u32, 480), converter1.getMusicXMLDivisions());
    
    const converter2 = try DivisionConverter.init(96, 0); // Should select optimal
    try std.testing.expect(converter2.getMusicXMLDivisions() > 0);
    
    const converter3 = try DivisionConverter.init(192, 0); // Should keep 192 or select compatible
    try std.testing.expect(converter3.getMusicXMLDivisions() > 0);
}

test "DivisionConverter - error handling" {
    // Test invalid PPQ
    try std.testing.expectError(TimingError.InvalidDivision, DivisionConverter.init(0, 480));
    
    // Test valid auto-selection (target_divisions = 0 should work)
    const converter_auto = try DivisionConverter.init(480, 0);
    try std.testing.expect(converter_auto.getMusicXMLDivisions() > 0);
    
    // Test overflow protection
    const converter = try DivisionConverter.init(480, 480);
    try std.testing.expectError(TimingError.InvalidTickValue, 
        converter.convertTicksToDivisions(std.math.maxInt(u32)));
}

test "DivisionConverter - performance benchmark" {
    const converter = try DivisionConverter.init(480, 480);
    
    const iterations: u32 = 10000;
    const duration_ns = benchmarkConversion(&converter, iterations);
    const duration_per_conversion_ns = duration_ns / iterations;
    const duration_per_conversion_us = @as(f64, @floatFromInt(duration_per_conversion_ns)) / 1000.0;
    
    std.debug.print("Division conversion time: {d:.3} μs per conversion (averaged over {} iterations)\n", 
        .{ duration_per_conversion_us, iterations });
    
    // Verify < 1μs per conversion performance target per TASK-023
    try std.testing.expect(duration_per_conversion_us < 1.0);
}

test "selectOptimalDivisions - common values" {
    // Test that common MIDI PPQ values get educational-optimal divisions
    try std.testing.expectEqual(@as(u32, 4), selectOptimalDivisions(96));   // Educational: quarter=4
    try std.testing.expectEqual(@as(u32, 8), selectOptimalDivisions(192));  // Educational: quarter=8
    try std.testing.expectEqual(@as(u32, 20), selectOptimalDivisions(480)); // Educational: quarter=20  
    try std.testing.expectEqual(@as(u32, 40), selectOptimalDivisions(960)); // Educational: quarter=40
    
    // Test uncommon values get reasonable selections
    const result_127 = selectOptimalDivisions(127);
    try std.testing.expect(result_127 > 0);
    
    const result_1000 = selectOptimalDivisions(1000);
    try std.testing.expect(result_1000 > 0);
}
